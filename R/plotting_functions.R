#' @title Add a shaded region showing the min/max quantiles
#'
#' @description Add a shaded region showing the min/max quantiles (usually
#' +/-2.5%) to a plot
#'
#' @details The input, an, is the result of a call to analyze_soln. It is a
#' list-like object of class bd_analysis with information on the quantiles
#' of the density function and growth rate. Typically, the min/max quantiles
#' are 2.5% and 97.5%, but this can be changed via the input lev in the call to
#' analyze_soln.
#'
#' @param an A list-like object of class \code{baydem::bd_analysis} with
#'   information on the quantiles of the density function and growth rate
#' @param col The color of the shaded region
#' @param ... Additional parameters to pass to \code{graphics::polygon}
#'
#' @export
add_shaded_quantiles <-
  function(an,
           col = grDevices::adjustcolor("grey",
             alpha.f = 0.5
           ),
           ...) {

    # The indidces of the minimum and maximum quantiles
    ind_min <- which.min(an$probs)
    ind_max <- which.max(an$probs)
    graphics::polygon(c(an$tau, rev(an$tau)),
      c(
        an$Qdens[ind_min, ],
        rev(an$Qdens[ind_max, ])
      ),
      border = NA,
      xlab = NULL,
      col = col
    )
  }

#' @title Prepare a blank plot for showing densities
#'
#' @description Prepare a blank plot for showing densities
#'
#' @details The input, an, is the result of a call to analyze_soln. It is a
#' list-like object of class bayDem_analysis with information on the quantiles
#' of the density function and growth rate. Prepare a blank plot for adding
#' density information, e.g. by calling plot_50_percent_quantile and
#' add_shaded_quantiles.R. If the axis labels and limits are not specified,
#' sensible defaults are used.
#'
#' @param an A list-like object of class \code{baydem::bd_analysis} with
#' information on the quantiles of the density function and growth rate
#' @param xlim Numeric vector of length 2, giving the x coordinate range
#' @param ylim Numeric vector of length 2, giving the y coordinate range
#' @param xlab x-axis label
#' @param ylab y-axis label
#' @param ... Additional parameters to pass to plot
#'
#' @export
make_blank_density_plot <-
  function(an,
           xlim = NA,
           ylim = NA,
           xlab = "Calendar Date [AD]",
           ylab = "Density",
           ...) {
    if (all(is.na(xlim))) {
      xlim <- range(an$tau)
    }

    if (all(is.na(ylim))) {
      # The following command works even if, e.g., f_sim is not in the list an
      # because an$f_sim results in NULL
      ylim <- c(0, max(c(max(an$Qdens), an$f_spdf, an$f_sim)))
    }

    graphics::plot(NULL,
      xlim = xlim,
      ylim = ylim,
      ylab = ylab,
      xlab = xlab,
      ...
    )
  }

#' @title Plot the 50 percent quantile curve
#'
#' @description Plot the 50% quantile curve
#'
#' @details The input, an, is the result of a call to analyze_soln. It is a
#' list-like object of class bayDem_analysis with information on the quantiles
#' of the density function and growth rate. By default, a new plot is made, but
#' if add = TRUE the curve is added to the active plot.
#'
#' @param an A list-like object of class \code{baydem::bd_analysis} with
#'   information on the quantiles of the density function and growth rate
#' @param add (default: `FALSE`) Whether to make a new plot or add to the active
#'   plot
#' @param ... Additional parameters to pass to plot / lines
#'
#' @export
plot_50_percent_quantile <- function(an, add = F, ...) {

  # The index of the 50 percent quantile
  ind50 <- which(an$probs == 0.5) # The index in probs / Qdens of the 50 percent quantile
  if (add) {
    graphics::lines(an$tau, an$Qdens[ind50, ], ...)
  } else {
    graphics::plot(an$tau, an$Qdens[ind50, ], type = "l", ...)
  }
}

#' @title Plot the known simulation density
#'
#' @description Plot the known simulation density
#'
#' @details The input, an, is the result of a call to analyze_soln. It is a
#' list-like object  with information on the quantiles of the density function
#' and growth rate. By default, a new plot is made, but if add = TRUE the curve
#'  is added to the active plot.
#'
#' @param an A list-like object generated by analyze_soln with information on
#'   the quantiles of the density function and growth rate
#' @param add (default: `FALSE`) Whether to make a new plot or add to the active
#'   plot
#' @param ... Additional parameters to pass to plot / lines
#'
#' @export
plot_known_sim_density <- function(an, add = F, ...) {
  if (add) {
    graphics::lines(an$tau, an$f_sim, ...)
  } else {
    graphics::plot(an$tau, an$f_sim, type = "l", ...)
  }
}

#' @title Plot the summed probability density function (SPDF)
#'
#' @description Plot the summed probability density function (SPDF)
#'
#' @details The input, an, is the result of a call to analyze_soln. It is a
#' list-like object of class bd_analysis with information on the quantiles of
#' the density function and growth rate. By default, a new plot is made, but if
#' add = TRUE the curve is added to the active plot.
#'
#' @param an A list-like object of class \code{baydem::bd_analysis} with
#'   information on the quantiles of the density function and growth rate
#' @param add (default: `FALSE`) Whether to make a new plot or add to the active
#'   plot
#' @param ... Additional parameters to pass to plot / lines
#'
#' @export
plot_summed_density <- function(an, add = F, ...) {
  if (add) {
    graphics::lines(an$tau, an$f_spdf, ...)
  } else {
    graphics::plot(an$tau, an$f_spdf, type = "l", ...)
  }
}

#' @title Visualize the calibration curve with equifinal and non-equifinal time
#'   spans
#'
#' @details
#' Vizualize the input calibration curve, calib_df, on the interval tau_min to
#' tau_max. This involves plotting the curve itself and shading invertible
#' (non-equifinal) and non-invertible (equifinal) regions.
#'
#' @param tau_min The minimum calendar date for plotting (AD)
#' @param tau_max The maximum calendar date for plotting (AD)
#' @param calib_df The calibration data frame, with columns year_BP,
#'   uncal_year_BP, and uncal_year_BP_error
#' @param invert_col (default: `gray90`) The color for shading invertible
#'   regions
#' @param point_col (default: `black`) The color for calibration curve points
#' @param point_pch (default: `19`) The symbol for calibration curve points
#' @param ... Additional inputs to plots
#'
#' @export
vis_calib_curve <-
  function(tau_min,
           tau_max,
           calib_df,
           invert_col = "gray90",
           point_col = "black",
           point_pch = 19,
           ...) {
    tau_curve <- 1950 - calib_df$year_BP
    phi_curve <- exp(-calib_df$uncal_year_BP / 8033)
    ind <- (tau_curve >= tau_min) & (tau_curve <= tau_max)
    tau_vect <- tau_curve[ind]
    phi_vect <- phi_curve[ind]
    phi_min <- min(phi_vect)
    phi_max <- max(phi_vect)

    # Create an empty plot
    graphics::plot(1, type = "n", xlim = c(tau_min, tau_max),
                   ylim = c(phi_min, phi_max), ...)

    equi_info <- assess_calib_curve_equif(calib_df)
    can_invert <- equi_info$can_invert
    inv_span_list <- equi_info$inv_span_list
    for (ii in 1:length(inv_span_list)) {
      inv_span <- inv_span_list[[ii]]
      if (dplyr::between(inv_span$tau_left, tau_min, tau_max) ||
        dplyr::between(inv_span$tau_right, tau_min, tau_max)) {
        graphics::rect(inv_span$tau_left, phi_min, inv_span$tau_right,
                       phi_max, border = NA, col = invert_col)
      }
    }

    # Draw calibration curve points
    graphics::points(tau_vect, phi_vect, col = point_col, pch = point_pch)
  }
